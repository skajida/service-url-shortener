### [`controller`](controller/)

В этом модуле реализуется gRPC обертка над сервисом. Использует сгенерированные  `protoc`-ом сущности из модуля [`pb`](pb/).

Для этого модуля написаны mock unit-тесты, mock-и также сгенерированны утилитой `mockgen` способом, указанном в [readme корня](/readme.md).


### [`entity`](entity/)

В этом модуле реализован паттерн генератор для обслуживания нужд сервиса.

Помимо сокрытия от сервиса способа генерации коротких урлов также с помощью канала инкапсулирует доступ к `*rand.Rand`, что защищает от data-race.

Генератор реализован следующим образом: фоном работает горутина, которая кладет в канал с буфером размера 1 сгенерированные ей урлы, в соседнем кейсе `select` проверяет, что контекст не закрыт. Для реализации graceful shutdown сущности генератор помимо контекста передается `*sync.WaitGroup`.

Для функции перевода `int64` в урл длины 10 написаны тесты, проверяющие, что крайние лексикографические значения достижимы.
Математически можно понять, что `63^10 < 2^60 < 2^63`, что примерно соответствует максимальному значению `int64`, поэтому 8 байт информации (необходимо, поскольку 7 байт не хватает, и) достаточно для кодирования любой строки с заданными параметрами.

### [`interceptor`](interceptor/)

В этом модуле описан recovery option для UnaryServerInterceptor, чтобы при панике gRPC сервиса, помимо восстановления, логгер записывал информацию об этом событии. `zap.Panic` кидает еще одну панику, доделывал этот grpc middleware в последний момент, поэтому использовал уровень `Error` в логгере.

### [`model`](model/)

В этом модуле описаны внутренние ошибки сервиса, которые валидируют контроль исполнения.

### [`pb`](pb/)

В этом модуле лежат сгенерированные protobuf-compiler-ом на основе [`url-shortener.proto`](/proto/url-shortener.proto) файла.

### [`repository`](repository/)

В этом модуле лежат две реализации репозитория урлов, удовлетворяющие [интерфейсу в контракте сервиса](service/contract.go).

Модуль аккуратно валидирует случаи добавления того же исходного урла, того же сокращения. Эта информация нужна для корректной логики основного сервиса.

Оба метода делают один поход в базу (в случае postgres).

### [`service`](service/)

Основная логика работы сервиса содержится в исходниках этого модуля.

При добавлении нового отображения ссылок модуль использует описанный выше [генератор случайных коротких ссылок](#entity) для их отправки на слой репозитория. Если репозиторий ответил, что оригинальная ссылка уже есть в базе, сервис возвращает ошибку. Если репозиторий ответил, что сокращение уже есть в базе (на маловероятный случай коллизии ГПСЧ), то сервис продолжает тянуть случайные урлы из генератора, пока не произойдет успех или непредвиденная ошибка.

При возвращении оригинального урла по короткому дополнительной логики не исполняет: просто пробрасывает ответ репозитория.

Для модуля сервиса написаны mock unit-тесты с валидацией поведения сервиса в зависимости от сценария взаимодействия с репозиторием.
